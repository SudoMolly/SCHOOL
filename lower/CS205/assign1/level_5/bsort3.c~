// For CS205, Portland State University (J. Li)

// Bubble sort in C (baseline version)

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

const int STRING = 4;

//Level 3 is first level to give me trouble, I tried previously to send as 1
//long int array; but does not fit with given arrays, so had to split in main.

// Print an int array of size n
//
//void printArray(char* msg, int* a, int n)
//void printArray(char* msg, char* a, int n)
void STRprintArray(char* msg, char** a, int n)
{
  printf("%s",msg);
  for (int i = 0; i < n; i++)
    printf("%s, ", a[i]);
    //printf("%d, ", a[i]);
  printf("\n");
}

// LEVEL 2 VERSION
// Swap two int array elements
//
//void swap(int* a, int i, int j)
/*
void swap(char* a, int i, int j)
{
  if (i != j) {
    int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
  }
}
*/

// Swaps the values of 2 given memory addresses, alloc'd as chars
//
//void swap(int* a, int i, int j)
//void swap(char* a, int i, int j)
void swap(char * i, char * j)
{
    //printf("%s", "ENTER SWAP\ni: ");
    //printf("%c", *i, 
  if (*i != *j) 
  {
    char tmp = *i;
    *i = *j;
    *j = tmp;
  }
}

// Bubble sort a range [low,high) of an int array
//
//void bsort(int* a, int low, int high)
//void bsort(char* a, int low, int high)
/*
void bsort(char* a, int low, int high)
{
  if (high - low > 1) 
    for (int i = low; i < high; i++)
      for (int j = i+1; j < high; j++) 
		if (a[i] > a[j])
		  swap(a, i, j);
}
*/

// String version of bubble sort, could have done pointer arithmetic to 
// take up less space, but I can actually comprehend this.
//
//Changes: row = i, limit acts as high, whereas high acts as # of rows, added
//         counter to help swap btw/n current row and next row, and j is
//         removed due to col/count making j obsolete.
//
void STRbsort(char** a, int low, int high)
{
    //printf("%s", "ENTER BSORT");
    char * pos1 = NULL;
    char * pos2 = NULL;
    if (high - low > 1) 
        for (int limit = (high * (STRING - 1)), count = 1; limit > low; --limit, count = 1)
            for (int row = low; row < high && count < limit; ++row)
                for (int col = 0; col < (STRING - 1) && count < limit; ++col, ++count) 
                {
                    if (col == 2)
                        pos2 = &(a[row + 1][0]);
                    else
                        pos2 = &(a[row][col + 1]);
                    pos1 = &(a[row][col]);
                    if (*pos1 > *pos2)
                        swap(pos1,pos2);
                }
}

//int * initArray(int n)
//char * initArray(int n)
char ** STRinitArray(int n)
{
    if (n <= 0) return NULL;
    int curr;
    //int limit = n * STRING;
    

    //int * array = (int*)malloc(n * sizeof(int));
    //Level 3 Implementation 1:
    //int * array = (int*)malloc((limit) * sizeof(int*));
    //Level 3 Implementation 3:
    char ** array = (char**)malloc(n * sizeof(char*));

    for (int i = 0; i < n ; ++i)
        array[i] = (char*)malloc(STRING * sizeof(char));

    for (int r = 0; r < n ; ++r)
    {
        for (int c = 0; c < (STRING - 1); ++c)
        {
            //srand(time(NULL) + ((r + c) * c));
            curr = ((rand() % 26) + 97);
            array[r][c] = (char)curr;
        }
        array[r][STRING-1] = '\0';
    }

    return array;
}

void MSGinitArray(int choice)
{
    switch (choice)
    {
        //Intialize array
        case (0):
        {
            printf("\nEnter array size: ");
            break;
        }

        //Error code
        case (1):
        {
            printf("n must be a positive integer\n");
            break;
        }
    }
}




